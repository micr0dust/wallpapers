<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>無盡公路</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #a0c0f0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <!-- Make sure these paths are correct relative to your HTML file -->
    <script src="three.min.js"></script>
    <script src="simplex-noise.js"></script>

    <script>
        // === 基本設定 ===
        // ... (保持不變) ...
        let scene, camera, renderer, clock;
        let roadSegments = []; let terrainSegments = []; let pillars = []; let embankmentSegments = [];
        let guardrailSegments = [];
        let treeInstances = [];
        const segmentLength = 40; const roadWidth = 8; const numSegments = 30;
        const terrainWidth = 600; const terrainDetail = 38;
        let driveSpeed = 15.0; let currentPathDistance = 0;
        let isPaused = false;
        let animationFrameId = null; // 用於 requestAnimationFrame 的 ID

        const MAX_DELTA_TIME = 0.5;

        // --- 噪音生成器 ---
        // ... (保持不變) ...
        const simplex = new SimplexNoise();
        const baseTerrainHeightFreq = 0.003; const baseTerrainHeightAmp = 60;
        const roadHeightVariationFreq = 0.015; const roadHeightVariationAmp = 8;
        const curveFrequency = 0.005; const curveAmplitude = 80;
        const terrainFrequency = 0.008; const terrainAmplitude = 55;


        // --- 相機參數 ---
        // ... (保持不變) ...
        const cameraHeight = 3.5; const cameraLookDistance = 45; const cameraFollowSpeed = 0.06;
        const rightLaneOffset = roadWidth * 0.25;
        let targetCameraPosition = new THREE.Vector3(); let targetLookAtPosition = new THREE.Vector3();


        // --- 高架橋參數 ---
        // ... (保持不變) ...
        const pillarCheckThreshold = 4.0; const pillarSpacing = 8.0; const pillarRadius = 0.5;
        const pillarMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });


        // --- 路基參數 ---
        // ... (保持不變) ...
        const roadBedOffset = -2.0;
        const roadForceRadius = roadWidth * 0.7;
        const roadBlendRadius = roadWidth * 3.8;
        const finalTerrainMaxHeightNearRoad = -0.5;


        // --- 土堆/路基網格參數 ---
        // ... (保持不變) ...
        const embankmentMaterial = new THREE.MeshStandardMaterial({ color: 0xc2b280, side: THREE.DoubleSide, flatShading: false });
        const embankmentSideExtendDistance = 8.0;
        let lastSegmentNeededEmbankment = false;

        // --- 地形顏色和裙邊 ---
        // ... (保持不變) ...
        const terrainColor = 0x6a9a6a;
        const terrainSkirtDrop = 30;

        // --- 樹木參數 ---
        // ... (保持不變) ...
        const treesPerSegment = 80;
        let treeGeometryTrunk, treeGeometryCanopy;
        let treeMaterialTrunk, treeMaterialCanopy;
        const treeScaleMin = 0.8; const treeScaleMax = 1.5;
        const clusterProbability = 0.35;
        const numTreesInCluster = 15;
        const clusterRadius = 18;
        const flatnessThreshold = 0.6;
        const treeAvoidRoadRadius = roadWidth * 2.5;

        // --- 護欄參數 ---
        // ... (保持不變) ...
        const guardrailHeight = 1.0;
        const postRadius = 0.1;
        const railHeight = 0.15;
        const railSpacing = 0.3;
        const guardrailMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.6, metalness: 0.4 });
        const guardrailThreshold = 2.5;

        // === 新增：動畫暫停/恢復函數 ===
        function pauseAnimation() {
            if (!isPaused) {
                console.log("Animation Paused");
                isPaused = true;
                // 不需要停止 clock 或取消 frame，animate 函數會處理
            }
        }

        function resumeAnimation() {
            if (isPaused) {
                console.log("Animation Resumed");
                isPaused = false;
                // **重要：** 重置 clock 的 delta time，避免時間跳躍
                if (clock) clock.getDelta();
            }
        }


        // --- 輔助函數：Smoothstep --- (不變)
        function smoothstep(edge0, edge1, x) { const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0))); return t * t * (3 - 2 * t); }

        // --- 輔助函數：獲取修正後的地形高度 --- (不變)
        function getModifiedTerrainHeight(worldX, worldZ) {
            const originalTerrainY = getEstimatedTerrainHeight(worldX, worldZ);
            const roadPathData = getPathPoint(-worldZ); const roadCenterX = roadPathData.position.x; const roadCenterY = roadPathData.position.y;
            const distToRoadCenter = Math.abs(worldX - roadCenterX); const targetBedY = roadCenterY + roadBedOffset; let finalY;
            if (distToRoadCenter <= roadBlendRadius) { const flattenFactor = 1.0 - smoothstep(roadForceRadius, roadBlendRadius, distToRoadCenter); const interpolatedBedY = THREE.MathUtils.lerp(targetBedY, roadCenterY + finalTerrainMaxHeightNearRoad, 1.0 - flattenFactor); finalY = Math.min(originalTerrainY, interpolatedBedY); finalY = Math.min(finalY, roadCenterY + finalTerrainMaxHeightNearRoad); } else { finalY = originalTerrainY; }
            return finalY;
        }

        function init() {
            clock = new THREE.Clock(); scene = new THREE.Scene(); scene.fog = new THREE.Fog(terrainColor, 60, 150);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(0xa0c0f0); document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xcccccc); scene.add(ambientLight); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); directionalLight.position.set(25, 40, 20); scene.add(directionalLight);

            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide });
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const terrainMaterial = new THREE.MeshStandardMaterial({ color: terrainColor, flatShading: false, side: THREE.DoubleSide });

            // **創建樹木基礎幾何體和材質**
            // ... (保持不變) ...
            treeGeometryTrunk = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 5); // 簡化樹幹
            treeGeometryCanopy = new THREE.ConeGeometry(0.8, 2.5, 6); // 簡化樹冠
            treeMaterialTrunk = new THREE.MeshLambertMaterial({ color: 0x8B4513 }); // 棕色
            treeMaterialCanopy = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // 森林綠


            // --- 創建初始 ---
            for (let i = 0; i < numSegments + 5; i++) { addTerrainSegment(i * segmentLength, terrainMaterial); }
            for (let i = 0; i < numSegments; i++) { addRoadSegment(i * segmentLength, roadMaterial, lineMaterial); }

            // --- **設置事件監聽器** ---
            setupVisibilityListeners();

            window.addEventListener('resize', onWindowResize, false);
            animate(); // Start the animation loop
        }

        // --- 計算原始地形估算高度 --- (不變)
        function getEstimatedTerrainHeight(worldX, worldZ) { const baseHeight = simplex.noise2D(5, -worldZ * baseTerrainHeightFreq) * baseTerrainHeightAmp; const terrainNoise = simplex.noise2D(worldX * terrainFrequency * 0.5, -worldZ * terrainFrequency) * terrainAmplitude; return baseHeight + terrainNoise; }

        // --- 計算路徑點、高度和方向 --- (不變)
        function getPathPoint(distance) { const curve = simplex.noise2D(0, -distance * curveFrequency) * curveAmplitude; const baseHeight = simplex.noise2D(5, -distance * baseTerrainHeightFreq) * baseTerrainHeightAmp; const roadVariation = simplex.noise2D(10, -distance * roadHeightVariationFreq) * roadHeightVariationAmp; const height = baseHeight + roadVariation; const position = new THREE.Vector3(curve, height, -distance); const aheadDistance = distance + 0.1; const curveAhead = simplex.noise2D(0, -aheadDistance * curveFrequency) * curveAmplitude; const baseHeightAhead = simplex.noise2D(5, -aheadDistance * baseTerrainHeightFreq) * baseTerrainHeightAmp; const roadVariationAhead = simplex.noise2D(10, -aheadDistance * roadHeightVariationFreq) * roadHeightVariationAmp; const heightAhead = baseHeightAhead + roadVariationAhead; const positionAhead = new THREE.Vector3(curveAhead, heightAhead, -aheadDistance); const tangent = positionAhead.clone().sub(position).normalize(); return { position, tangent }; }

        // --- 創建路段、柱子、土堆和護欄 ---
        function addRoadSegment(startDistance, roadMat, lineMat) {
            // ... (大部分代碼保持不變) ...
            const prevHadEmbankment = lastSegmentNeededEmbankment;
            const segmentDetail = 15; const points = []; const tangents = []; const normals = [];
            const up = new THREE.Vector3(0, 1, 0);
            for (let i = 0; i <= segmentDetail; i++) { const d = startDistance + (i / segmentDetail) * segmentLength; const pathData = getPathPoint(d); points.push(pathData.position); tangents.push(pathData.tangent); }
            for (let i = 0; i <= segmentDetail; i++) { const currentTangent = tangents[i]; let normal = new THREE.Vector3().crossVectors(currentTangent, up).normalize(); if (Math.abs(currentTangent.y) > 0.98) { normal.crossVectors(currentTangent, new THREE.Vector3(1, 0, 0)).normalize(); if (normal.lengthSq() < 0.1) { normal.crossVectors(currentTangent, new THREE.Vector3(0, 0, 1)).normalize(); } } normals.push(normal); }

            const roadVertices = []; const lineVertices = []; const embankmentVertices = [];
            const leftGuardrailVertices = [];
            const rightGuardrailVertices = [];
            const halfWidth = roadWidth / 2; let distanceAlongSegment = 0; let lastPillarPos = -Infinity;
            let needsEmbankmentMesh = false; let needsGuardrailMesh = false;
            let first_v1 = null, first_v2 = null, first_eb1 = null, first_eb2 = null;

            for (let i = 0; i < segmentDetail; i++) {
                const p1 = points[i]; const p2 = points[i + 1];
                const n1 = normals[i]; const n2 = normals[i + 1];
                const v1 = p1.clone().add(n1.clone().multiplyScalar(-halfWidth)); const v2 = p1.clone().add(n1.clone().multiplyScalar(halfWidth)); const v3 = p2.clone().add(n2.clone().multiplyScalar(halfWidth)); const v4 = p2.clone().add(n2.clone().multiplyScalar(-halfWidth));
                roadVertices.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v4.x, v4.y, v4.z); roadVertices.push(v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, v4.x, v4.y, v4.z);
                const segmentPartLength = p1.distanceTo(p2);
                // Mid-line... (unchanged)
                let segmentPartTraversed = 0; const dashLength = 2; const dashGap = 2; let currentDashPosLocal = 0; let inDashLocal = true; let totalDistStartOfPart = startDistance + distanceAlongSegment; inDashLocal = (Math.floor(totalDistStartOfPart / (dashLength + dashGap)) % 2 === 0); currentDashPosLocal = totalDistStartOfPart % (dashLength + dashGap); if (!inDashLocal) currentDashPosLocal -= dashLength; while (segmentPartTraversed < segmentPartLength) { const remainingInPart = segmentPartLength - segmentPartTraversed; const currentPhaseLength = inDashLocal ? dashLength : dashGap; const stepLength = Math.min(remainingInPart, currentPhaseLength - currentDashPosLocal); if (inDashLocal) { const startLerp = segmentPartTraversed / segmentPartLength; const endLerp = (segmentPartTraversed + stepLength) / segmentPartLength; const dashStart = p1.clone().lerp(p2, startLerp); const dashEnd = p1.clone().lerp(p2, endLerp); lineVertices.push(dashStart.x, dashStart.y + 0.05, dashStart.z); lineVertices.push(dashEnd.x, dashEnd.y + 0.05, dashEnd.z); } currentDashPosLocal += stepLength; segmentPartTraversed += stepLength; if (currentDashPosLocal >= currentPhaseLength) { inDashLocal = !inDashLocal; currentDashPosLocal = 0; } }

                // --- Check for Pillar / Embankment / Guardrail ---
                const checkPoint = p1.clone().lerp(p2, 0.5); const currentTotalDistance = startDistance + distanceAlongSegment + segmentPartLength * 0.5;
                const terrainRawY = getEstimatedTerrainHeight(checkPoint.x, checkPoint.z); const roadY = checkPoint.y;
                const heightDiff = roadY - terrainRawY; let segmentNeedsPillar = false;

                if (heightDiff > pillarCheckThreshold) {
                    segmentNeedsPillar = true;
                    if (currentTotalDistance - lastPillarPos >= pillarSpacing) { addPillar(checkPoint, roadY, terrainRawY, startDistance); lastPillarPos = currentTotalDistance; }
                }

                // Check for Embankment (unchanged condition)
                const targetBedLevel = roadY + roadBedOffset;
                const currentPieceNeedsEmbankment = !segmentNeedsPillar && terrainRawY > targetBedLevel + 0.1;
                if (currentPieceNeedsEmbankment) {
                    needsEmbankmentMesh = true;
                    // Calculate embankment vertices... (unchanged)
                    const eb1_xz_vec = n1.clone().multiplyScalar(-embankmentSideExtendDistance); const eb2_xz_vec = n1.clone().multiplyScalar(embankmentSideExtendDistance); const eb3_xz_vec = n2.clone().multiplyScalar(embankmentSideExtendDistance); const eb4_xz_vec = n2.clone().multiplyScalar(-embankmentSideExtendDistance);
                    const eb1_x = v1.x + eb1_xz_vec.x; const eb1_z = v1.z + eb1_xz_vec.z; const eb2_x = v2.x + eb2_xz_vec.x; const eb2_z = v2.z + eb2_xz_vec.z; const eb3_x = v3.x + eb3_xz_vec.x; const eb3_z = v3.z + eb3_xz_vec.z; const eb4_x = v4.x + eb4_xz_vec.x; const eb4_z = v4.z + eb4_xz_vec.z;
                    const terrain_eb1_y = getModifiedTerrainHeight(eb1_x, eb1_z); const terrain_eb2_y = getModifiedTerrainHeight(eb2_x, eb2_z); const terrain_eb3_y = getModifiedTerrainHeight(eb3_x, eb3_z); const terrain_eb4_y = getModifiedTerrainHeight(eb4_x, eb4_z);
                    const eb1_y = Math.min(terrain_eb1_y, v1.y) - 1.0; const eb2_y = Math.min(terrain_eb2_y, v2.y) - 1.0; const eb3_y = Math.min(terrain_eb3_y, v3.y) - 1.0; const eb4_y = Math.min(terrain_eb4_y, v4.y) - 1.0;
                    const eb1 = new THREE.Vector3(eb1_x, eb1_y, eb1_z); const eb2 = new THREE.Vector3(eb2_x, eb2_y, eb2_z); const eb3 = new THREE.Vector3(eb3_x, eb3_y, eb3_z); const eb4 = new THREE.Vector3(eb4_x, eb4_y, eb4_z);
                    embankmentVertices.push(v1.x, v1.y, v1.z, v4.x, v4.y, v4.z, eb1.x, eb1.y, eb1.z); embankmentVertices.push(v4.x, v4.y, v4.z, eb4.x, eb4.y, eb4.z, eb1.x, eb1.y, eb1.z); embankmentVertices.push(v2.x, v2.y, v2.z, v3.x, v3.y, v3.z, eb2.x, eb2.y, eb2.z); embankmentVertices.push(v3.x, v3.y, v3.z, eb3.x, eb3.y, eb3.z, eb2.x, eb2.y, eb2.z); embankmentVertices.push(eb1.x, eb1.y, eb1.z, eb4.x, eb4.y, eb4.z, eb2.x, eb2.y, eb2.z); embankmentVertices.push(eb4.x, eb4.y, eb4.z, eb3.x, eb3.y, eb3.z, eb2.x, eb2.y, eb2.z);
                    if (first_v1 === null) { first_v1 = v1.clone(); first_v2 = v2.clone(); first_eb1 = eb1.clone(); first_eb2 = eb2.clone(); }
                }

                // **Check for Guardrail** (unchanged)
                if (heightDiff > guardrailThreshold && !currentPieceNeedsEmbankment) {
                    needsGuardrailMesh = true;
                    const postOffset = 0.1;
                    // --- Left Guardrail --- (unchanged)
                    const post1_base = v1.clone().add(n1.clone().multiplyScalar(postOffset)); const post4_base = v4.clone().add(n2.clone().multiplyScalar(postOffset)); const post1_top = post1_base.clone().add(up.clone().multiplyScalar(guardrailHeight)); const post4_top = post4_base.clone().add(up.clone().multiplyScalar(guardrailHeight));
                    leftGuardrailVertices.push(post1_base.x - postRadius, post1_base.y, post1_base.z, post1_base.x + postRadius, post1_base.y, post1_base.z, post1_top.x - postRadius, post1_top.y, post1_top.z); leftGuardrailVertices.push(post1_base.x + postRadius, post1_base.y, post1_base.z, post1_top.x + postRadius, post1_top.y, post1_top.z, post1_top.x - postRadius, post1_top.y, post1_top.z); const rail1_bl = post1_top.clone().sub(up.clone().multiplyScalar(railHeight)); const rail1_br = post4_top.clone().sub(up.clone().multiplyScalar(railHeight)); leftGuardrailVertices.push(rail1_bl.x, rail1_bl.y, rail1_bl.z, rail1_br.x, rail1_br.y, rail1_br.z, post1_top.x, post1_top.y, post1_top.z); leftGuardrailVertices.push(rail1_br.x, rail1_br.y, rail1_br.z, post4_top.x, post4_top.y, post4_top.z, post1_top.x, post1_top.y, post1_top.z); const rail2_tl = rail1_bl.clone().sub(up.clone().multiplyScalar(railSpacing)); const rail2_tr = rail1_br.clone().sub(up.clone().multiplyScalar(railSpacing)); const rail2_bl = rail2_tl.clone().sub(up.clone().multiplyScalar(railHeight)); const rail2_br = rail2_tr.clone().sub(up.clone().multiplyScalar(railHeight)); leftGuardrailVertices.push(rail2_bl.x, rail2_bl.y, rail2_bl.z, rail2_br.x, rail2_br.y, rail2_br.z, rail2_tl.x, rail2_tl.y, rail2_tl.z); leftGuardrailVertices.push(rail2_br.x, rail2_br.y, rail2_br.z, rail2_tr.x, rail2_tr.y, rail2_tr.z, rail2_tl.x, rail2_tl.y, rail2_tl.z);
                    // --- Right Guardrail --- (unchanged)
                    const post2_base = v2.clone().add(n1.clone().multiplyScalar(-postOffset)); const post3_base = v3.clone().add(n2.clone().multiplyScalar(-postOffset)); const post2_top = post2_base.clone().add(up.clone().multiplyScalar(guardrailHeight)); const post3_top = post3_base.clone().add(up.clone().multiplyScalar(guardrailHeight)); rightGuardrailVertices.push(post2_base.x - postRadius, post2_base.y, post2_base.z, post2_base.x + postRadius, post2_base.y, post2_base.z, post2_top.x - postRadius, post2_top.y, post2_top.z); rightGuardrailVertices.push(post2_base.x + postRadius, post2_base.y, post2_base.z, post2_top.x + postRadius, post2_top.y, post2_top.z, post2_top.x - postRadius, post2_top.y, post2_top.z); const r_rail1_bl = post2_top.clone().sub(up.clone().multiplyScalar(railHeight)); const r_rail1_br = post3_top.clone().sub(up.clone().multiplyScalar(railHeight)); rightGuardrailVertices.push(r_rail1_bl.x, r_rail1_bl.y, r_rail1_bl.z, post2_top.x, post2_top.y, post2_top.z, r_rail1_br.x, r_rail1_br.y, r_rail1_br.z); rightGuardrailVertices.push(r_rail1_br.x, r_rail1_br.y, r_rail1_br.z, post2_top.x, post2_top.y, post2_top.z, post3_top.x, post3_top.y, post3_top.z); const r_rail2_tl = r_rail1_bl.clone().sub(up.clone().multiplyScalar(railSpacing)); const r_rail2_tr = r_rail1_br.clone().sub(up.clone().multiplyScalar(railSpacing)); const r_rail2_bl = r_rail2_tl.clone().sub(up.clone().multiplyScalar(railHeight)); const r_rail2_br = r_rail2_tr.clone().sub(up.clone().multiplyScalar(railHeight)); rightGuardrailVertices.push(r_rail2_bl.x, r_rail2_bl.y, r_rail2_bl.z, r_rail2_tl.x, r_rail2_tl.y, r_rail2_tl.z, r_rail2_br.x, r_rail2_br.y, r_rail2_br.z); rightGuardrailVertices.push(r_rail2_br.x, r_rail2_br.y, r_rail2_br.z, r_rail2_tl.x, r_rail2_tl.y, r_rail2_tl.z, r_rail2_tr.x, r_rail2_tr.y, r_rail2_tr.z);
                }

                distanceAlongSegment += segmentPartLength;
            } // End for segmentDetail

            // --- Start/End Pillar Check --- (unchanged)
            const startPoint = points[0]; const startTerrainRawY = getEstimatedTerrainHeight(startPoint.x, startPoint.z); if (startPoint.y - startTerrainRawY > pillarCheckThreshold) { addPillar(startPoint, startPoint.y, startTerrainRawY, startDistance); } const endPoint = points[segmentDetail]; const endTerrainRawY = getEstimatedTerrainHeight(endPoint.x, endPoint.z); if (endPoint.y - endTerrainRawY > pillarCheckThreshold && (startDistance + segmentLength) - lastPillarPos >= pillarSpacing / 2) { addPillar(endPoint, endPoint.y, endTerrainRawY, startDistance); }

            // --- Create Road/Line Meshes --- (unchanged)
            const roadGeometry = new THREE.BufferGeometry(); roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(roadVertices, 3)); roadGeometry.computeVertexNormals(); const roadMesh = new THREE.Mesh(roadGeometry, roadMat); roadMesh.userData = { type: 'road', distance: startDistance }; scene.add(roadMesh); roadSegments.push(roadMesh);
            if (lineVertices.length > 0) { const lineGeometry = new THREE.BufferGeometry(); lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3)); const lineMesh = new THREE.LineSegments(lineGeometry, lineMat); lineMesh.userData = { type: 'line', distance: startDistance }; scene.add(lineMesh); roadSegments.push(lineMesh); }

            // --- Create Embankment Mesh (with start slope if needed) --- (unchanged)
            if (needsEmbankmentMesh && embankmentVertices.length > 0) {
                if (!prevHadEmbankment && first_v1 !== null) { embankmentVertices.push(first_v1.x, first_v1.y, first_v1.z, first_eb1.x, first_eb1.y, first_eb1.z, first_eb2.x, first_eb2.y, first_eb2.z); embankmentVertices.push(first_v1.x, first_v1.y, first_v1.z, first_eb2.x, first_eb2.y, first_eb2.z, first_v2.x, first_v2.y, first_v2.z); }
                const embankmentGeometry = new THREE.BufferGeometry(); embankmentGeometry.setAttribute('position', new THREE.Float32BufferAttribute(embankmentVertices, 3)); embankmentGeometry.computeVertexNormals(); const embankmentMesh = new THREE.Mesh(embankmentGeometry, embankmentMaterial); embankmentMesh.userData = { type: 'embankment', distance: startDistance }; scene.add(embankmentMesh); embankmentSegments.push(embankmentMesh);
            }

            // --- **Create Guardrail Meshes** --- (unchanged)
            if (needsGuardrailMesh) {
                if (leftGuardrailVertices.length > 0) { const leftGuardrailGeom = new THREE.BufferGeometry(); leftGuardrailGeom.setAttribute('position', new THREE.Float32BufferAttribute(leftGuardrailVertices, 3)); leftGuardrailGeom.computeVertexNormals(); const leftGuardrailMesh = new THREE.Mesh(leftGuardrailGeom, guardrailMaterial); leftGuardrailMesh.userData = { type: 'guardrail', distance: startDistance }; scene.add(leftGuardrailMesh); guardrailSegments.push(leftGuardrailMesh); }
                if (rightGuardrailVertices.length > 0) { const rightGuardrailGeom = new THREE.BufferGeometry(); rightGuardrailGeom.setAttribute('position', new THREE.Float32BufferAttribute(rightGuardrailVertices, 3)); rightGuardrailGeom.computeVertexNormals(); const rightGuardrailMesh = new THREE.Mesh(rightGuardrailGeom, guardrailMaterial); rightGuardrailMesh.userData = { type: 'guardrail', distance: startDistance }; scene.add(rightGuardrailMesh); guardrailSegments.push(rightGuardrailMesh); }
            }

            lastSegmentNeededEmbankment = needsEmbankmentMesh; // Update global state
        }


        // --- 添加柱子 --- (不變)
        function addPillar(roadCenterPos, roadY, terrainRawY, segmentStartDistance) { const height = roadY - terrainRawY; if (height <= 0.1) return; const pillarBottomY = terrainRawY; const pillarTopY = roadY - 0.1; const actualHeight = pillarTopY - pillarBottomY; if (actualHeight <= 0.1) return; const pillarGeometry = new THREE.CylinderGeometry(pillarRadius, pillarRadius, actualHeight, 8); const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial); pillar.position.set(roadCenterPos.x, pillarBottomY + actualHeight / 2, roadCenterPos.z); pillar.userData = { type: 'pillar', distance: segmentStartDistance }; scene.add(pillar); pillars.push(pillar); }

        // --- 創建帶裙邊的地形和樹木 (叢生、平地) ---
        function addTerrainSegment(startDistance, terrainMat) {
            // ... (大部分代碼保持不變) ...
            const planeDetailX = terrainDetail; const planeDetailY = Math.max(1, Math.floor(segmentLength / 5));
            const terrainGeometry = new THREE.PlaneGeometry(terrainWidth, segmentLength, planeDetailX, planeDetailY);
            const vertices = terrainGeometry.attributes.position; const vertexCount = vertices.count;
            const worldPositions = new Float32Array(vertexCount * 3);
            const centerPathPoint = getPathPoint(startDistance + segmentLength / 2); const tolerance = 0.01;

            const treeMatrices = [];
            const dummy = new THREE.Object3D();

            // 1. 計算地形頂點 (不變)
            for (let i = 0; i < vertexCount; i++) { const localX = vertices.getX(i); const localY = vertices.getY(i); const worldZ = centerPathPoint.position.z - localY; const worldX = centerPathPoint.position.x + localX; const finalY = getModifiedTerrainHeight(worldX, worldZ); worldPositions[i * 3] = worldX; worldPositions[i * 3 + 1] = finalY; worldPositions[i * 3 + 2] = worldZ; }

            // 2. **嘗試生成樹木叢集** (不變)
            const clusterLocalX = Math.random() * terrainWidth - terrainWidth / 2; const clusterLocalY = Math.random() * segmentLength - segmentLength / 2; const clusterWorldX = centerPathPoint.position.x + clusterLocalX; const clusterWorldZ = centerPathPoint.position.z - clusterLocalY; const roadPathDataCenter = getPathPoint(-clusterWorldZ); const roadCenterX = roadPathDataCenter.position.x; const distToRoadCenter = Math.abs(clusterWorldX - roadCenterX);
            if (distToRoadCenter > treeAvoidRoadRadius) { const hCenter = getEstimatedTerrainHeight(clusterWorldX, clusterWorldZ); const hOffsetX = getEstimatedTerrainHeight(clusterWorldX + 1.0, clusterWorldZ); const hOffsetZ = getEstimatedTerrainHeight(clusterWorldX, clusterWorldZ + 1.0); if (Math.abs(hCenter - hOffsetX) < flatnessThreshold && Math.abs(hCenter - hOffsetZ) < flatnessThreshold) { const actualTrees = Math.round(numTreesInCluster * (0.75 + Math.random() * 0.5)); for (let j = 0; j < actualTrees; j++) { const angle = Math.random() * Math.PI * 2; const radius = Math.random() * clusterRadius; const treeX = clusterWorldX + Math.cos(angle) * radius; const treeZ = clusterWorldZ + Math.sin(angle) * radius; const treeY = getModifiedTerrainHeight(treeX, treeZ); dummy.position.set(treeX, treeY, treeZ); dummy.rotation.y = Math.random() * Math.PI * 2; const scale = THREE.MathUtils.randFloat(treeScaleMin, treeScaleMax); dummy.scale.set(scale, scale, scale); dummy.updateMatrix(); treeMatrices.push(dummy.matrix.clone()); } } }

            // 3. 修改邊界頂點創建裙邊 (不變)
            for (let i = 0; i < vertexCount; i++) { const localX = vertices.getX(i); const localY = vertices.getY(i); const isBoundary = Math.abs(localX - (-terrainWidth / 2)) < tolerance || Math.abs(localX - (terrainWidth / 2)) < tolerance || Math.abs(localY - (-segmentLength / 2)) < tolerance || Math.abs(localY - (segmentLength / 2)) < tolerance; if (isBoundary) { worldPositions[i * 3 + 1] -= terrainSkirtDrop; } }

            // 4. 創建地形 Mesh (不變)
            const finalTerrainGeo = new THREE.BufferGeometry(); finalTerrainGeo.setAttribute('position', new THREE.Float32BufferAttribute(worldPositions, 3)); finalTerrainGeo.setIndex(terrainGeometry.index); finalTerrainGeo.computeVertexNormals(); const finalTerrainMesh = new THREE.Mesh(finalTerrainGeo, terrainMat); finalTerrainMesh.userData = { type: 'terrain', distance: startDistance }; scene.add(finalTerrainMesh); terrainSegments.push(finalTerrainMesh);

            // 5. **創建樹木 InstancedMesh (如果生成了樹)** (不變)
            if (treeMatrices.length > 0) { const treeCount = treeMatrices.length; const instancedTrunk = new THREE.InstancedMesh(treeGeometryTrunk, treeMaterialTrunk, treeCount); const instancedCanopy = new THREE.InstancedMesh(treeGeometryCanopy, treeMaterialCanopy, treeCount); const canopyOffset = 1.3; for (let i = 0; i < treeCount; i++) { const trunkMatrix = treeMatrices[i]; const canopyMatrix = trunkMatrix.clone(); const position = new THREE.Vector3(); const quaternion = new THREE.Quaternion(); const scale = new THREE.Vector3(); trunkMatrix.decompose(position, quaternion, scale); position.y += canopyOffset * scale.y; canopyMatrix.compose(position, quaternion, scale); instancedTrunk.setMatrixAt(i, trunkMatrix); instancedCanopy.setMatrixAt(i, canopyMatrix); } instancedTrunk.instanceMatrix.needsUpdate = true; instancedCanopy.instanceMatrix.needsUpdate = true; instancedTrunk.userData = { type: 'trees', distance: startDistance }; instancedCanopy.userData = { type: 'trees', distance: startDistance }; scene.add(instancedTrunk); scene.add(instancedCanopy); treeInstances.push(instancedTrunk); treeInstances.push(instancedCanopy); }
        }

        // === 新增：動畫暫停/恢復函數 ===
        function pauseAnimation() {
            if (!isPaused) {
                console.log("Animation Paused");
                isPaused = true;
                // clock.stop(); // Stop the clock to prevent large deltaTime jump
                // We might not need to cancel the frame if animate() checks isPaused first
                // if (animationFrameId) cancelAnimationFrame(animationFrameId);
                // animationFrameId = null;
            }
        }

        function resumeAnimation() {
            if (isPaused) {
                console.log("Animation Resumed");
                isPaused = false;
                // clock.start(); // Restart the clock
                 clock.getDelta(); // **Important:** Call getDelta once to reset the internal timer after pause
                // Request the next frame if the loop wasn't running
                // if (!animationFrameId) {
                //     animate();
                // }
                 // The animate loop should restart itself because requestAnimationFrame is at the top
            }
        }

        // === 修改：設置可見性/焦點監聽器 ===
        function setupVisibilityListeners() {
            // --- 標準瀏覽器可見性 API (保持不變) ---
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log("Browser detected hidden state."); // 添加日誌
                    pauseAnimation();
                } else {
                    console.log("Browser detected visible state."); // 添加日誌
                    resumeAnimation();
                }
            });

            // --- 焦點 / 失去焦點事件 (保持不變，但可選，因為WE可能有自己的處理) ---
            window.addEventListener('blur', () => {
                console.log("Browser detected blur."); // 添加日誌
                // pauseAnimation(); // 可以考慮在WE環境下註解掉，避免衝突
            });
            window.addEventListener('focus', () => {
                console.log("Browser detected focus."); // 添加日誌
                // resumeAnimation(); // 可以考慮在WE環境下註解掉
            });


            // --- Wallpaper Engine 可見性與暫停處理 (改進) ---
            if (window.wallpaperPropertyListener) {
                console.log("Wallpaper Engine API detected. Setting up WE listener.");
                window.wallpaperPropertyListener.applyUserProperties = function(properties) {
                    // **新增：打印收到的所有屬性，方便調試**
                    console.log("WE received properties:", JSON.stringify(properties));

                    let shouldPause = false;

                    // 檢查 'visibility' 屬性 (如果WE提供)
                    if (properties.visibility) {
                        if (properties.visibility.value === false) {
                            console.log("WE property 'visibility' is false.");
                            shouldPause = true;
                        } else {
                            console.log("WE property 'visibility' is true.");
                            // 如果 visibility 為 true，先假設不暫停，但下面可能被 pause 覆蓋
                        }
                    }

                    // **新增：檢查常見的 'pause' 屬性 (或其他你可能在 project.json 定義的)**
                    // 你需要確定 WE 實際發送的屬性名稱是什麼。 'pause' 是一個常見的例子。
                    if (properties.pause) { // <--- 嘗試監聽名為 'pause' 的屬性
                        if (properties.pause.value === true) {
                            console.log("WE property 'pause' is true.");
                            shouldPause = true; // 如果 pause 為 true，強制暫停
                        } else {
                            console.log("WE property 'pause' is false.");
                            // 如果 pause 為 false，即使 visibility 為 false (理論上不該發生)，也可能不暫停？
                            // 通常 pause:false 優先級不高，主要看 pause:true 和 visibility:false
                        }
                    }

                    // **根據最終判斷來執行動作**
                    if (shouldPause) {
                        pauseAnimation();
                    } else {
                        // 只有在沒有任何暫停條件時才恢復
                        // （防止 visibility:true 但 pause:true 的情況下錯誤地恢復）
                        if (!isPaused) { // 避免不必要的 resume 調用
                            // console.log("No pause conditions met, ensuring resumed state.");
                        } else {
                            resumeAnimation();
                        }
                    }
                };
                // **新增：請求 WE 在初始化時發送一次當前屬性狀態**
                // 這有助於確保初始狀態正確，而不是等待第一次屬性變更
                // 注意：這不是標準 API，但有時有用，或者 WE 會自動發送初始狀態
                if (window.wallpaperRequestUserProperties) {
                    console.log("Requesting initial WE properties.");
                    window.wallpaperRequestUserProperties();
                }

            } else {
                console.log("Wallpaper Engine API not detected, relying solely on browser events.");
            }
}
        // --- 動畫循環 (修改) ---
        function animate() {
            // Request the next frame **before** doing work.
            // This ensures the loop continues even if paused.
            animationFrameId = requestAnimationFrame(animate);

            // **If paused, skip all updates and rendering**
            if (isPaused) {
                return;
            }

            // --- Proceed with animation if not paused ---
            const deltaTime = clock.getDelta(); // Get time since last *rendered* frame

            if (deltaTime > MAX_DELTA_TIME) {
                // 打印日誌到控制台（如果 console.log 能工作的話）
                // console.log(`DeltaTime too large (${deltaTime.toFixed(3)}s), skipping update. Likely resumed from pause.`);

                // **直接跳過本幀的遊戲邏輯更新**
                // 你可以選擇是否渲染這一幀，通常渲染一下比較好，避免畫面卡住
                if (renderer && scene && camera) {
                     renderer.render(scene, camera);
                }
                return; // 退出 animate 函數，等待下一幀 rAF 回調
            }

            // **Only update game state if time has actually passed**
            // (Helps avoid issues if deltaTime is zero right after resuming)
            if (deltaTime > 0) {
                currentPathDistance += driveSpeed * deltaTime;

                const cameraPathData = getPathPoint(currentPathDistance);
                const camPos = cameraPathData.position;
                const camTangent = cameraPathData.tangent;
                const up = new THREE.Vector3(0, 1, 0);
                const rightNormal = new THREE.Vector3().crossVectors(camTangent, up).normalize();
                const targetPos = camPos.clone().add(up.multiplyScalar(cameraHeight)).add(rightNormal.multiplyScalar(rightLaneOffset));
                const lookAtPos = camPos.clone().add(camTangent.multiplyScalar(cameraLookDistance));

                camera.position.lerp(targetPos, cameraFollowSpeed);
                targetLookAtPosition.lerp(lookAtPos, cameraFollowSpeed);
                camera.lookAt(targetLookAtPosition);

                // --- 管理 (回收與生成) ---
                const recycleThreshold = 80; const generateThreshold = (numSegments - 4) * segmentLength;
                // **回收樹木**
                const treesToRemove = []; treeInstances.forEach((t, i) => { if ((-t.userData.distance - segmentLength) > camera.position.z + recycleThreshold) { treesToRemove.push(i); scene.remove(t); t.geometry.dispose(); if(t.material) t.material.dispose(); } }); for (let i = treesToRemove.length - 1; i >= 0; i--) treeInstances.splice(treesToRemove[i], 1);
                // **回收護欄**
                const guardrailsToRemove = []; guardrailSegments.forEach((g, i) => { if ((-g.userData.distance - segmentLength) > camera.position.z + recycleThreshold) { guardrailsToRemove.push(i); scene.remove(g); if (g.geometry) g.geometry.dispose(); } }); for (let i = guardrailsToRemove.length - 1; i >= 0; i--) guardrailSegments.splice(guardrailsToRemove[i], 1);
                // ...(其他回收邏輯不變)...
                const embankmentToRemove = []; embankmentSegments.forEach((e, i) => { if ((-e.userData.distance - segmentLength) > camera.position.z + recycleThreshold) { embankmentToRemove.push(i); scene.remove(e); if (e.geometry) e.geometry.dispose(); } }); for (let i = embankmentToRemove.length - 1; i >= 0; i--) embankmentSegments.splice(embankmentToRemove[i], 1); const segmentsToRemove = []; roadSegments.forEach((s, i) => { if ((-s.userData.distance - segmentLength) > camera.position.z + recycleThreshold) { segmentsToRemove.push(i); scene.remove(s); if (s.geometry) s.geometry.dispose(); } }); for (let i = segmentsToRemove.length - 1; i >= 0; i--) roadSegments.splice(segmentsToRemove[i], 1); const terrainToRemove = []; terrainSegments.forEach((s, i) => { if ((-s.userData.distance - segmentLength) > camera.position.z + recycleThreshold) { terrainToRemove.push(i); scene.remove(s); if (s.geometry) s.geometry.dispose(); } }); for (let i = terrainToRemove.length - 1; i >= 0; i--) terrainSegments.splice(terrainToRemove[i], 1); const pillarsToRemove = []; pillars.forEach((p, i) => { if (p.position.z > camera.position.z + recycleThreshold + segmentLength) { pillarsToRemove.push(i); scene.remove(p); if (p.geometry) p.geometry.dispose(); } }); for (let i = pillarsToRemove.length - 1; i >= 0; i--) pillars.splice(pillarsToRemove[i], 1); let maxDistance = 0; roadSegments.forEach(s => maxDistance = Math.max(maxDistance, s.userData.distance)); let maxTerrainDistance = 0; terrainSegments.forEach(s => maxTerrainDistance = Math.max(maxTerrainDistance, s.userData.distance)); const furthestPointRequired = currentPathDistance + generateThreshold; while (maxTerrainDistance < furthestPointRequired + segmentLength * 3) { const nextTerrainStart = maxTerrainDistance + segmentLength; if (terrainSegments.length > 0 && terrainSegments[0].material) { addTerrainSegment(nextTerrainStart, terrainSegments[0].material); maxTerrainDistance = nextTerrainStart; } else if (scene.getObjectByName("terrainMaterialPlaceholder")) { /* Handle case where initial material needed */ addTerrainSegment(nextTerrainStart, scene.getObjectByName("terrainMaterialPlaceholder").material); maxTerrainDistance = nextTerrainStart; } else { /* Fallback or break if no material found */ console.warn("Cannot find terrain material to add new segment."); break; } } while (maxDistance < furthestPointRequired) { const nextSegmentStart = maxDistance + segmentLength; if (roadSegments.length > 1 && roadSegments[0].material && roadSegments[1].material) { addRoadSegment(nextSegmentStart, roadSegments[0].material, roadSegments[1].material); maxDistance = nextSegmentStart; } else if (scene.getObjectByName("roadMaterialPlaceholder") && scene.getObjectByName("lineMaterialPlaceholder")) { /* Handle case where initial materials needed */ addRoadSegment(nextSegmentStart, scene.getObjectByName("roadMaterialPlaceholder").material, scene.getObjectByName("lineMaterialPlaceholder").material); maxDistance = nextSegmentStart; } else { /* Fallback or break */ console.warn("Cannot find road/line materials to add new segment."); break; } }
                 // **Ensure materials are disposed correctly during cleanup**
                // (Added dispose calls in the recycle loops above)

            } // End of deltaTime > 0 check

            // --- Render the scene ---
             if (renderer && scene && camera) { // Add check for safety
                 renderer.render(scene, camera);
             }

        } // End animate()

        // --- 窗口大小調整 --- (不變)
        function onWindowResize() {
            if (camera && renderer) { // Add check
                 camera.aspect = window.innerWidth / window.innerHeight;
                 camera.updateProjectionMatrix();
                 renderer.setSize(window.innerWidth, window.innerHeight);
             }
        }

        // --- 初始化 ---
        try {
            init();
        } catch (error) {
            console.error("Initialization failed:", error);
            // Optionally display an error message to the user
            document.body.innerHTML = "<p>抱歉，載入時發生錯誤。請檢查主控台以獲取詳細資訊。</p>";
        }


    </script>
</body>

</html>